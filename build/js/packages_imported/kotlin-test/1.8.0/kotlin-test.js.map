{"version":3,"file":"kotlin-test.js","sources":["./src/kotlin/util/Preconditions.kt","./src/kotlin/util/Result.kt","./js/src/kotlin/math.kt","./AssertContentEqualsImpl.kt","./Assertions.kt","./src/kotlin/text/Strings.kt","./DefaultAsserter.kt","./src/main/kotlin/kotlin/test/JsImpl.kt","./Utils.kt","./src/kotlin/util/Standard.kt","./src/main/kotlin/JsTestApi.kt","./src/main/kotlin/kotlin/test/Annotations.kt","./src/main/kotlin/kotlin/test/DefaultJsAsserter.kt","./src/main/kotlin/kotlin/test/TestApi.kt","./src/kotlin/jsTypeOf.kt","./src/main/kotlin/kotlin/test/adapters/BareAdapter.kt","./src/main/kotlin/kotlin/test/adapters/Externals.kt","./src/main/kotlin/kotlin/test/adapters/JasmineLikeAdapter.kt","./src/main/kotlin/kotlin/test/adapters/QUnitAdapter.kt"],"sourcesContent":["/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNCHECKED_CAST\", \"RedundantVisibilityModifier\")\n\npackage kotlin\n\nimport kotlin.contracts.*\nimport kotlin.internal.InlineOnly\nimport kotlin.jvm.JvmField\nimport kotlin.jvm.JvmInline\nimport kotlin.jvm.JvmName\n\n/**\n * A discriminated union that encapsulates a successful outcome with a value of type [T]\n * or a failure with an arbitrary [Throwable] exception.\n */\n@SinceKotlin(\"1.3\")\n@JvmInline\npublic value class Result<out T> @PublishedApi internal constructor(\n    @PublishedApi\n    internal val value: Any?\n) : Serializable {\n    // discovery\n\n    /**\n     * Returns `true` if this instance represents a successful outcome.\n     * In this case [isFailure] returns `false`.\n     */\n    public val isSuccess: Boolean get() = value !is Failure\n\n    /**\n     * Returns `true` if this instance represents a failed outcome.\n     * In this case [isSuccess] returns `false`.\n     */\n    public val isFailure: Boolean get() = value is Failure\n\n    // value & exception retrieval\n\n    /**\n     * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or `null`\n     * if it is [failure][Result.isFailure].\n     *\n     * This function is a shorthand for `getOrElse { null }` (see [getOrElse]) or\n     * `fold(onSuccess = { it }, onFailure = { null })` (see [fold]).\n     */\n    @InlineOnly\n    public inline fun getOrNull(): T? =\n        when {\n            isFailure -> null\n            else -> value as T\n        }\n\n    /**\n     * Returns the encapsulated [Throwable] exception if this instance represents [failure][isFailure] or `null`\n     * if it is [success][isSuccess].\n     *\n     * This function is a shorthand for `fold(onSuccess = { null }, onFailure = { it })` (see [fold]).\n     */\n    public fun exceptionOrNull(): Throwable? =\n        when (value) {\n            is Failure -> value.exception\n            else -> null\n        }\n\n    /**\n     * Returns a string `Success(v)` if this instance represents [success][Result.isSuccess]\n     * where `v` is a string representation of the value or a string `Failure(x)` if\n     * it is [failure][isFailure] where `x` is a string representation of the exception.\n     */\n    public override fun toString(): String =\n        when (value) {\n            is Failure -> value.toString() // \"Failure($exception)\"\n            else -> \"Success($value)\"\n        }\n\n    // companion with constructors\n\n    /**\n     * Companion object for [Result] class that contains its constructor functions\n     * [success] and [failure].\n     */\n    public companion object {\n        /**\n         * Returns an instance that encapsulates the given [value] as successful value.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"success\")\n        public inline fun <T> success(value: T): Result<T> =\n            Result(value)\n\n        /**\n         * Returns an instance that encapsulates the given [Throwable] [exception] as failure.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"failure\")\n        public inline fun <T> failure(exception: Throwable): Result<T> =\n            Result(createFailure(exception))\n    }\n\n    internal class Failure(\n        @JvmField\n        val exception: Throwable\n    ) : Serializable {\n        override fun equals(other: Any?): Boolean = other is Failure && exception == other.exception\n        override fun hashCode(): Int = exception.hashCode()\n        override fun toString(): String = \"Failure($exception)\"\n    }\n}\n\n/**\n * Creates an instance of internal marker [Result.Failure] class to\n * make sure that this class is not exposed in ABI.\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun createFailure(exception: Throwable): Any =\n    Result.Failure(exception)\n\n/**\n * Throws exception if the result is failure. This internal function minimizes\n * inlined bytecode for [getOrThrow] and makes sure that in the future we can\n * add some exception-augmenting logic here (if needed).\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun Result<*>.throwOnFailure() {\n    if (value is Result.Failure) throw value.exception\n}\n\n/**\n * Calls the specified function [block] and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R> runCatching(block: () -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T, R> T.runCatching(block: T.() -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n// -- extensions ---\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or throws the encapsulated [Throwable] exception\n * if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { throw it }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.getOrThrow(): T {\n    throwOnFailure()\n    return value as T\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onFailure] function.\n *\n * This function is a shorthand for `fold(onSuccess = { it }, onFailure = onFailure)` (see [fold]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrElse(onFailure: (exception: Throwable) -> R): R {\n    contract {\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> value as T\n        else -> onFailure(exception)\n    }\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * [defaultValue] if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { defaultValue }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrDefault(defaultValue: R): R {\n    if (isFailure) return defaultValue\n    return value as T\n}\n\n/**\n * Returns the result of [onSuccess] for the encapsulated value if this instance represents [success][Result.isSuccess]\n * or the result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onSuccess] or by [onFailure] function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.fold(\n    onSuccess: (value: T) -> R,\n    onFailure: (exception: Throwable) -> R\n): R {\n    contract {\n        callsInPlace(onSuccess, InvocationKind.AT_MOST_ONCE)\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> onSuccess(value as T)\n        else -> onFailure(exception)\n    }\n}\n\n// transformation\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [mapCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.map(transform: (value: T) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when {\n        isSuccess -> Result.success(transform(value as T))\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [map] for an alternative that rethrows exceptions from `transform` function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.mapCatching(transform: (value: T) -> R): Result<R> {\n    return when {\n        isSuccess -> runCatching { transform(value as T) }\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [recoverCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recover(transform: (exception: Throwable) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> Result.success(transform(exception))\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [recover] for an alternative that rethrows exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recoverCatching(transform: (exception: Throwable) -> R): Result<R> {\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> runCatching { transform(exception) }\n    }\n}\n\n// \"peek\" onto value/exception and pipe\n\n/**\n * Performs the given [action] on the encapsulated [Throwable] exception if this instance represents [failure][Result.isFailure].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onFailure(action: (exception: Throwable) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    exceptionOrNull()?.let { action(it) }\n    return this\n}\n\n/**\n * Performs the given [action] on the encapsulated value if this instance represents [success][Result.isSuccess].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onSuccess(action: (value: T) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    if (isSuccess) action(value as T)\n    return this\n}\n\n// -------------------\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.JsMath as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeSinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeCosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeTanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeAsinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeAcosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeAtanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeHypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeExpm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeLog10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeLog2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeLog1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x)\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x)\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeTrunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x)\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeSign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n\n/**\n * Returns the cube root of [x]. For any `x`, `cbrt(-x) == -cbrt(x)`;\n * that is, the cube root of a negative value is the negative of the cube root\n * of that value's magnitude. Special cases:\n *\n * Special cases:\n *   - If the argument is `NaN`, then the result is `NaN`.\n *   - If the argument is infinite, then the result is an infinity with the same sign as the argument.\n *   - If the argument is zero, then the result is a zero with the same sign as the argument.\n */\n@SinceKotlin(\"1.8\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@InlineOnly\npublic actual inline fun cbrt(x: Double): Double = nativeMath.cbrt(x)\n\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeSign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeSinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeCosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeTanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeAsinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeAcosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeAtanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeHypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeExpm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeLog10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeLog2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeLog1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeSign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n\n/**\n * Returns the cube root of [x]. For any `x`, `cbrt(-x) == -cbrt(x)`;\n * that is, the cube root of a negative value is the negative of the cube root\n * of that value's magnitude. Special cases:\n *\n * Special cases:\n *   - If the argument is `NaN`, then the result is `NaN`.\n *   - If the argument is infinite, then the result is an infinity with the same sign as the argument.\n *   - If the argument is zero, then the result is a zero with the same sign as the argument.\n */\n@SinceKotlin(\"1.8\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@InlineOnly\npublic actual inline fun cbrt(x: Float): Float = nativeMath.cbrt(x.toDouble()).toFloat()\n\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeSign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test\n\nimport kotlin.contracts.contract\n\ninternal fun <T> assertIterableContentEquals(\n    typeName: String,\n    message: String?,\n    expected: T?,\n    actual: T?,\n    iterator: T.() -> Iterator<*>\n) {\n    if (checkReferenceAndNullEquality(typeName, message, expected, actual, Any?::toString)) return\n\n    var index = 0\n    val expectedIt = expected.iterator()\n    val actualIt = actual.iterator()\n\n    while (expectedIt.hasNext() && actualIt.hasNext()) {\n        val expectedElement = expectedIt.next()\n        val actualElement = actualIt.next()\n\n        if (expectedElement != actualElement) {\n            fail(messagePrefix(message) + elementsDifferMessage(typeName, index, expectedElement, actualElement))\n        }\n\n        index++\n    }\n\n    if (expectedIt.hasNext()) {\n        check(!actualIt.hasNext())\n\n        fail(messagePrefix(message) + \"$typeName lengths differ. Expected length is bigger than $index, actual length is $index.\")\n    }\n\n    if (actualIt.hasNext()) {\n        check(!expectedIt.hasNext())\n\n        fail(messagePrefix(message) + \"$typeName lengths differ. Expected length is $index, actual length is bigger than $index.\")\n    }\n}\n\ninternal fun <T> assertArrayContentEquals(\n    message: String?,\n    expected: T?,\n    actual: T?,\n    size: (T) -> Int,\n    get: T.(Int) -> Any?,\n    contentToString: T?.() -> String,\n    contentEquals: T?.(T?) -> Boolean\n) {\n    if (expected.contentEquals(actual)) return\n\n    val typeName = \"Array\"\n\n    if (checkReferenceAndNullEquality(typeName, message, expected, actual, contentToString)) return\n\n    val expectedSize = size(expected)\n    val actualSize = size(actual)\n\n    if (expectedSize != actualSize) {\n        val sizesDifferMessage = \"$typeName sizes differ. Expected size is $expectedSize, actual size is $actualSize.\"\n        val toString = \"Expected <${expected.contentToString()}>, actual <${actual.contentToString()}>.\"\n\n        fail(messagePrefix(message) + sizesDifferMessage + \"\\n\" + toString)\n    }\n\n    for (index in 0 until expectedSize) {\n        val expectedElement = expected.get(index)\n        val actualElement = actual.get(index)\n\n        if (expectedElement != actualElement) {\n            val elementsDifferMessage = elementsDifferMessage(typeName, index, expectedElement, actualElement)\n            val toString = \"Expected <${expected.contentToString()}>, actual <${actual.contentToString()}>.\"\n\n            fail(messagePrefix(message) + elementsDifferMessage + \"\\n\" + toString)\n        }\n    }\n}\n\nprivate fun <T> checkReferenceAndNullEquality(\n    typeName: String,\n    message: String?,\n    expected: T?,\n    actual: T?,\n    contentToString: T?.() -> String\n): Boolean {\n    contract {\n        returns(false) implies (expected != null && actual != null)\n    }\n\n    if (expected === actual) {\n        return true\n    }\n    if (expected == null) {\n        fail(messagePrefix(message) + \"Expected <null> $typeName, actual <${actual.contentToString()}>.\")\n    }\n    if (actual == null) {\n        fail(messagePrefix(message) + \"Expected non-null $typeName <${expected.contentToString()}>, actual <null>.\")\n    }\n\n    return false\n}\n\nprivate fun elementsDifferMessage(typeName: String, index: Int, expectedElement: Any?, actualElement: Any?): String =\n    \"$typeName elements differ at index $index. Expected element <$expectedElement>, actual element <${actualElement}>.\"","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/**\n * A number of helper methods for writing unit tests.\n */\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"AssertionsKt\")\n@file:Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n\npackage kotlin.test\n\nimport kotlin.contracts.*\nimport kotlin.internal.*\nimport kotlin.jvm.JvmName\nimport kotlin.native.concurrent.ThreadLocal\nimport kotlin.reflect.KClass\nimport kotlin.reflect.KType\nimport kotlin.reflect.typeOf\n\n/**\n * Current adapter providing assertion implementations\n */\nval asserter: Asserter\n    get() = _asserter ?: lookupAsserter()\n\n/** Used to override current asserter internally */\n@ThreadLocal\ninternal var _asserter: Asserter? = null\n\n/** Asserts that the given [block] returns `true`. */\n@JvmName(\"assertTrueInline\")\n@InlineOnly\ninline fun assertTrue(message: String? = null, block: () -> Boolean) {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    assertTrue(block(), message)\n}\n\n/** Asserts that the expression is `true` with an optional [message]. */\nfun assertTrue(actual: Boolean, message: String? = null) {\n    contract { returns() implies actual }\n    return asserter.assertTrue(message ?: \"Expected value to be true.\", actual)\n}\n\n/** Asserts that the given [block] returns `false`. */\n@JvmName(\"assertFalseInline\")\n@InlineOnly\ninline fun assertFalse(message: String? = null, block: () -> Boolean) {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    assertFalse(block(), message)\n}\n\n/** Asserts that the expression is `false` with an optional [message]. */\nfun assertFalse(actual: Boolean, message: String? = null) {\n    contract { returns() implies (!actual) }\n    return asserter.assertTrue(message ?: \"Expected value to be false.\", !actual)\n}\n\n/** Asserts that the [expected] value is equal to the [actual] value, with an optional [message]. */\nfun <@OnlyInputTypes T> assertEquals(expected: T, actual: T, message: String? = null) {\n    asserter.assertEquals(message, expected, actual)\n}\n\n/** Asserts that the difference between the [actual] and the [expected] is within an [absoluteTolerance], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertEquals(expected: Double, actual: Double, absoluteTolerance: Double, message: String? = null) {\n    checkDoublesAreEqual(expected, actual, absoluteTolerance, message)\n}\n\n/** Asserts that the difference between the [actual] and the [expected] is within an [absoluteTolerance], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertEquals(expected: Float, actual: Float, absoluteTolerance: Float, message: String? = null) {\n    checkFloatsAreEqual(expected, actual, absoluteTolerance, message)\n}\n\n/** Asserts that the [actual] value is not equal to the illegal value, with an optional [message]. */\nfun <@OnlyInputTypes T> assertNotEquals(illegal: T, actual: T, message: String? = null) {\n    asserter.assertNotEquals(message, illegal, actual)\n}\n\n/** Asserts that the difference between the [actual] and the [illegal] is not within an [absoluteTolerance], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertNotEquals(illegal: Double, actual: Double, absoluteTolerance: Double, message: String? = null) {\n    checkDoublesAreEqual(illegal, actual, absoluteTolerance, message, shouldFail = true)\n}\n\n/** Asserts that the difference between the [actual] and the [illegal] is not within an [absoluteTolerance], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertNotEquals(illegal: Float, actual: Float, absoluteTolerance: Float, message: String? = null) {\n    checkFloatsAreEqual(illegal, actual, absoluteTolerance, message, shouldFail = true)\n}\n\n/** Asserts that [expected] is the same instance as [actual], with an optional [message]. */\nfun <@OnlyInputTypes T> assertSame(expected: T, actual: T, message: String? = null) {\n    asserter.assertSame(message, expected, actual)\n}\n\n/** Asserts that [actual] is not the same instance as [illegal], with an optional [message]. */\nfun <@OnlyInputTypes T> assertNotSame(illegal: T, actual: T, message: String? = null) {\n    asserter.assertNotSame(message, illegal, actual)\n}\n\n/**\n * Asserts that [value] is of type [T], with an optional [message].\n *\n * Note that due to type erasure the type check may be partial (e.g. `assertIs<List<String>>(value)`\n * only checks for the class being [List] and not the type of its elements because it's erased).\n */\n@SinceKotlin(\"1.5\")\n@InlineOnly\n@OptIn(ExperimentalStdlibApi::class)\ninline fun <reified T> assertIs(value: Any?, message: String? = null): T {\n    contract { returns() implies (value is T) }\n    assertIsOfType(value, typeOf<T>(), value is T, message)\n    return value as T\n}\n\n@PublishedApi\ninternal fun assertIsOfType(value: Any?, type: KType, result: Boolean, message: String?) {\n    asserter.assertTrue({ messagePrefix(message) + \"Expected value to be of type <$type>, actual <${value?.let { it::class }}>.\" }, result)\n}\n\n/**\n * Asserts that [value] is not of type [T], with an optional [message].\n *\n * Note that due to type erasure the type check may be partial (e.g. `assertIsNot<List<String>>(value)`\n * only checks for the class being [List] and not the type of its elements because it's erased).\n */\n@SinceKotlin(\"1.5\")\n@InlineOnly\ninline fun <reified T> assertIsNot(value: Any?, message: String? = null) {\n    assertIsNotOfType(value, typeOf<T>(), value !is T, message)\n}\n\n@PublishedApi\ninternal fun assertIsNotOfType(@Suppress(\"UNUSED_PARAMETER\") value: Any?, type: KType, result: Boolean, message: String?) {\n    asserter.assertTrue({ messagePrefix(message) + \"Expected value to not be of type <$type>.\" }, result)\n}\n\n/** Asserts that the [actual] value is not `null`, with an optional [message]. */\nfun <T : Any> assertNotNull(actual: T?, message: String? = null): T {\n    contract { returns() implies (actual != null) }\n    asserter.assertNotNull(message, actual)\n    return actual!!\n}\n\n/** Asserts that the [actual] value is not `null`, with an optional [message] and a function [block] to process the not-null value. */\n@JvmName(\"assertNotNullInline\")\n@InlineOnly\ninline fun <T : Any, R> assertNotNull(actual: T?, message: String? = null, block: (T) -> R) {\n    contract { returns() implies (actual != null) }\n    block(assertNotNull(actual, message))\n}\n\n/** Asserts that the [actual] value is `null`, with an optional [message]. */\nfun assertNull(actual: Any?, message: String? = null) {\n    asserter.assertNull(message, actual)\n}\n\n/** Asserts that the [iterable] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun <@OnlyInputTypes T> assertContains(iterable: Iterable<T>, element: T, message: String? = null) {\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected the collection to contain the element.\\nCollection <$iterable>, element <$element>.\" },\n        iterable.contains(element)\n    )\n}\n\n/** Asserts that the [sequence] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun <@OnlyInputTypes T> assertContains(sequence: Sequence<T>, element: T, message: String? = null) {\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected the sequence to contain the element.\\nSequence <$sequence>, element <$element>.\" },\n        sequence.contains(element)\n    )\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun <@OnlyInputTypes T> assertContains(array: Array<T>, element: T, message: String? = null) {\n    assertArrayContains(array, element, message, Array<T>::contains, Array<T>::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(array: ByteArray, element: Byte, message: String? = null) {\n    assertArrayContains(array, element, message, ByteArray::contains, ByteArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(array: ShortArray, element: Short, message: String? = null) {\n    assertArrayContains(array, element, message, ShortArray::contains, ShortArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(array: IntArray, element: Int, message: String? = null) {\n    assertArrayContains(array, element, message, IntArray::contains, IntArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(array: LongArray, element: Long, message: String? = null) {\n    assertArrayContains(array, element, message, LongArray::contains, LongArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(array: BooleanArray, element: Boolean, message: String? = null) {\n    assertArrayContains(array, element, message, BooleanArray::contains, BooleanArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(array: CharArray, element: Char, message: String? = null) {\n    assertArrayContains(array, element, message, CharArray::contains, CharArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContains(array: UByteArray, element: UByte, message: String? = null) {\n    assertArrayContains(array, element, message, UByteArray::contains, UByteArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContains(array: UShortArray, element: UShort, message: String? = null) {\n    assertArrayContains(array, element, message, UShortArray::contains, UShortArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContains(array: UIntArray, element: UInt, message: String? = null) {\n    assertArrayContains(array, element, message, UIntArray::contains, UIntArray::contentToString)\n}\n\n/** Asserts that the [array] contains the specified [element], with an optional [message]. */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContains(array: ULongArray, element: ULong, message: String? = null) {\n    assertArrayContains(array, element, message, ULongArray::contains, ULongArray::contentToString)\n}\n\n@kotlin.internal.InlineOnly\nprivate inline fun <@OnlyInputTypes A, E> assertArrayContains(\n    array: A,\n    element: E,\n    message: String? = null,\n    contains: A.(E) -> Boolean,\n    crossinline contentToString: A.() -> String\n) {\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected the array to contain the element.\\nArray <${array.contentToString()}>, element <${element.toString()}>.\" }, // Explicitly call toString(): KT-45684\n        array.contains(element)\n    )\n}\n\n/** Asserts that the [range] contains the specified [value], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(range: IntRange, value: Int, message: String? = null) {\n    assertRangeContains(range, value, message, IntRange::contains)\n}\n\n/** Asserts that the [range] contains the specified [value], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(range: LongRange, value: Long, message: String? = null) {\n    assertRangeContains(range, value, message, LongRange::contains)\n}\n\n/** Asserts that the [range] contains the specified [value], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun <T : Comparable<T>> assertContains(range: ClosedRange<T>, value: T, message: String? = null) {\n    assertRangeContains(range, value, message, ClosedRange<T>::contains)\n}\n\n/** Asserts that the [range] contains the specified [value], with an optional [message]. */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\nfun <T : Comparable<T>> assertContains(range: OpenEndRange<T>, value: T, message: String? = null) {\n    assertRangeContains(range, value, message, OpenEndRange<T>::contains)\n}\n\n/** Asserts that the [range] contains the specified [value], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(range: CharRange, value: Char, message: String? = null) {\n    assertRangeContains(range, value, message, CharRange::contains)\n}\n\n/** Asserts that the [range] contains the specified [value], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(range: UIntRange, value: UInt, message: String? = null) {\n    assertRangeContains(range, value, message, UIntRange::contains)\n}\n\n/** Asserts that the [range] contains the specified [value], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(range: ULongRange, value: ULong, message: String? = null) {\n    assertRangeContains(range, value, message, ULongRange::contains)\n}\n\n@kotlin.internal.InlineOnly\nprivate inline fun <R, V> assertRangeContains(range: R, value: V, message: String? = null, contains: R.(V) -> Boolean) {\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected the range <$range> to contain the value <${value.toString()}>.\" }, // Explicitly call toString(): KT-45684\n        range.contains(value)\n    )\n}\n\n/** Asserts that the [map] contains the specified [key], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun <@OnlyInputTypes K, V> assertContains(map: Map<K, V>, key: K, message: String? = null) {\n    asserter.assertTrue({ messagePrefix(message) + \"Expected the map to contain the key.\\nMap <$map>, key <$key>.\" }, map.containsKey(key))\n}\n\n/**\n * Asserts that the [charSequence] contains the specified [char], with an optional [message].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@SinceKotlin(\"1.5\")\nfun assertContains(charSequence: CharSequence, char: Char, ignoreCase: Boolean = false, message: String? = null) {\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected the char sequence to contain the char.\\nCharSequence <$charSequence>, char <$char>, ignoreCase <$ignoreCase>.\" },\n        charSequence.contains(char, ignoreCase)\n    )\n}\n\n/**\n * Asserts that the [charSequence] contains the specified [other] char sequence as a substring, with an optional [message].\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@SinceKotlin(\"1.5\")\nfun assertContains(charSequence: CharSequence, other: CharSequence, ignoreCase: Boolean = false, message: String? = null) {\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected the char sequence to contain the substring.\\nCharSequence <$charSequence>, substring <$other>, ignoreCase <$ignoreCase>.\" },\n        charSequence.contains(other, ignoreCase)\n    )\n}\n\n/** Asserts that the [charSequence] contains at least one match of the specified regular expression [regex], with an optional [message]. */\n@SinceKotlin(\"1.5\")\nfun assertContains(charSequence: CharSequence, regex: Regex, message: String? = null) {\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected the char sequence to contain the regular expression.\\nCharSequence <$charSequence>, regex <$regex>.\" },\n        charSequence.contains(regex)\n    )\n}\n\n/**\n * Asserts that the [expected] iterable is *structurally* equal to the [actual] iterable,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n *\n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.5\")\nfun <@OnlyInputTypes T> assertContentEquals(expected: Iterable<T>?, actual: Iterable<T>?, message: String? = null) {\n    assertIterableContentEquals(\"Iterable\", message, expected, actual, Iterable<*>::iterator)\n}\n\n\n@SinceKotlin(\"1.5\")\n@Deprecated(\"'assertContentEquals' for Set arguments is ambiguous. Use 'assertEquals' to compare content with the unordered set equality, or cast one of arguments to Iterable to compare the set elements in order of iteration.\",\n            level = DeprecationLevel.ERROR,\n            replaceWith = ReplaceWith(\"assertContentEquals(expected, actual?.asIterable(), message)\"))\nfun <@OnlyInputTypes T> assertContentEquals(expected: Set<T>?, actual: Set<T>?, message: String? = null): Unit =\n    assertContentEquals(expected, actual?.asIterable(), message)\n\n/**\n * Asserts that the [expected] sequence is *structurally* equal to the [actual] sequence,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n *\n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.5\")\nfun <@OnlyInputTypes T> assertContentEquals(expected: Sequence<T>?, actual: Sequence<T>?, message: String? = null) {\n    assertIterableContentEquals(\"Sequence\", message, expected, actual, Sequence<*>::iterator)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n *\n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.5\")\nfun <@OnlyInputTypes T> assertContentEquals(expected: Array<T>?, actual: Array<T>?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, Array<*>::get, Array<*>?::contentToString, Array<*>?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: ByteArray?, actual: ByteArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, ByteArray::get, ByteArray?::contentToString, ByteArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: ShortArray?, actual: ShortArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, ShortArray::get, ShortArray?::contentToString, ShortArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: IntArray?, actual: IntArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, IntArray::get, IntArray?::contentToString, IntArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: LongArray?, actual: LongArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, LongArray::get, LongArray?::contentToString, LongArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n *\n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: FloatArray?, actual: FloatArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, FloatArray::get, FloatArray?::contentToString, FloatArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n *\n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: DoubleArray?, actual: DoubleArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, DoubleArray::get, DoubleArray?::contentToString, DoubleArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: BooleanArray?, actual: BooleanArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, BooleanArray::get, BooleanArray?::contentToString, BooleanArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\nfun assertContentEquals(expected: CharArray?, actual: CharArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, CharArray::get, CharArray?::contentToString, CharArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContentEquals(expected: UByteArray?, actual: UByteArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, UByteArray::get, UByteArray?::contentToString, UByteArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContentEquals(expected: UShortArray?, actual: UShortArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, UShortArray::get, UShortArray?::contentToString, UShortArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContentEquals(expected: UIntArray?, actual: UIntArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, UIntArray::get, UIntArray?::contentToString, UIntArray?::contentEquals)\n}\n\n/**\n * Asserts that the [expected] array is *structurally* equal to the [actual] array,\n * i.e. contains the same number of the same elements in the same order, with an optional [message].\n */\n@SinceKotlin(\"1.5\")\n@OptIn(ExperimentalUnsignedTypes::class)\nfun assertContentEquals(expected: ULongArray?, actual: ULongArray?, message: String? = null) {\n    assertArrayContentEquals(message, expected, actual, { it.size }, ULongArray::get, ULongArray?::contentToString, ULongArray?::contentEquals)\n}\n\n/** Marks a test as having failed if this point in the execution path is reached, with an optional [message]. */\nfun fail(message: String? = null): Nothing {\n    asserter.fail(message)\n}\n\n/**\n * Marks a test as having failed if this point in the execution path is reached, with an optional [message]\n * and [cause] exception.\n *\n * The [cause] exception is set as the root cause of the test failure.\n */\n@SinceKotlin(\"1.4\")\nfun fail(message: String? = null, cause: Throwable? = null): Nothing {\n    asserter.fail(message, cause)\n}\n\n/** Asserts that given function [block] returns the given [expected] value. */\n@JvmName(\"expectInline\")\n@InlineOnly\ninline fun <@OnlyInputTypes T> expect(expected: T, block: () -> T) {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    assertEquals(expected, block())\n}\n\n/** Asserts that given function [block] returns the given [expected] value and use the given [message] if it fails. */\n@JvmName(\"expectInline\")\n@InlineOnly\ninline fun <@OnlyInputTypes T> expect(expected: T, message: String?, block: () -> T) {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    assertEquals(expected, block(), message)\n}\n\n/**\n * Asserts that given function [block] fails by throwing an exception.\n *\n * @return An exception that was expected to be thrown and was successfully caught.\n * The returned exception can be inspected further, for example by asserting its property values.\n */\n@InlineOnly\n@JvmName(\"assertFailsInline\")\ninline fun assertFails(block: () -> Unit): Throwable =\n    checkResultIsFailure(null, runCatching(block))\n\n/**\n * Asserts that given function [block] fails by throwing an exception.\n *\n * If the assertion fails, the specified [message] is used unless it is null as a prefix for the failure message.\n *\n * @return An exception that was expected to be thrown and was successfully caught.\n * The returned exception can be inspected further, for example by asserting its property values.\n */\n@SinceKotlin(\"1.1\")\n@InlineOnly\n@JvmName(\"assertFailsInline\")\ninline fun assertFails(message: String?, block: () -> Unit): Throwable =\n    checkResultIsFailure(message, runCatching(block))\n\n@PublishedApi\ninternal fun checkResultIsFailure(message: String?, blockResult: Result<Unit>): Throwable {\n    blockResult.fold(\n        onSuccess = {\n            asserter.fail(messagePrefix(message) + \"Expected an exception to be thrown, but was completed successfully.\")\n        },\n        onFailure = { e ->\n            return e\n        }\n    )\n}\n\n/** Asserts that a [block] fails with a specific exception of type [T] being thrown.\n *\n * If the assertion fails, the specified [message] is used unless it is null as a prefix for the failure message.\n *\n * @return An exception of the expected exception type [T] that successfully caught.\n * The returned exception can be inspected further, for example by asserting its property values.\n */\n@InlineOnly\ninline fun <reified T : Throwable> assertFailsWith(message: String? = null, block: () -> Unit): T =\n    assertFailsWith(T::class, message, block)\n\n/**\n * Asserts that a [block] fails with a specific exception of type [exceptionClass] being thrown.\n *\n * @return An exception of the expected exception type [T] that successfully caught.\n * The returned exception can be inspected further, for example by asserting its property values.\n */\n@InlineOnly\n@JvmName(\"assertFailsWithInline\")\ninline fun <T : Throwable> assertFailsWith(exceptionClass: KClass<T>, block: () -> Unit): T = assertFailsWith(exceptionClass, null, block)\n\n/**\n * Asserts that a [block] fails with a specific exception of type [exceptionClass] being thrown.\n *\n * If the assertion fails, the specified [message] is used unless it is null as a prefix for the failure message.\n *\n * @return An exception of the expected exception type [T] that successfully caught.\n * The returned exception can be inspected further, for example by asserting its property values.\n */\n@InlineOnly\n@JvmName(\"assertFailsWithInline\")\ninline fun <T : Throwable> assertFailsWith(exceptionClass: KClass<T>, message: String?, block: () -> Unit): T =\n    checkResultIsFailure(exceptionClass, message, runCatching(block))\n\n/** Platform-specific construction of AssertionError with cause */\ninternal expect fun AssertionErrorWithCause(message: String?, cause: Throwable?): AssertionError\n\n/**\n * Abstracts the logic for performing assertions. Specific implementations of [Asserter] can use JUnit\n * or TestNG assertion facilities.\n */\ninterface Asserter {\n    /**\n     * Fails the current test with the specified message.\n     *\n     * @param message the message to report.\n     */\n    fun fail(message: String?): Nothing\n\n    /**\n     * Fails the current test with the specified message and cause exception.\n     *\n     * @param message the message to report.\n     * @param cause the exception to set as the root cause of the reported failure.\n     */\n    @SinceKotlin(\"1.4\")\n    fun fail(message: String?, cause: Throwable?): Nothing\n\n    /**\n     * Asserts that the specified value is `true`.\n     *\n     * @param lazyMessage the function to return a message to report if the assertion fails.\n     */\n    fun assertTrue(lazyMessage: () -> String?, actual: Boolean): Unit {\n        if (!actual) {\n            fail(lazyMessage())\n        }\n    }\n\n    /**\n     * Asserts that the specified value is `true`.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertTrue(message: String?, actual: Boolean): Unit {\n        assertTrue({ message }, actual)\n    }\n\n    /**\n     * Asserts that the specified values are equal.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertEquals(message: String?, expected: Any?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Expected <$expected>, actual <$actual>.\" }, actual == expected)\n    }\n\n    /**\n     * Asserts that the specified values are not equal.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertNotEquals(message: String?, illegal: Any?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Illegal value: <$actual>.\" }, actual != illegal)\n    }\n\n    /**\n     * Asserts that the specified values are the same instance.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertSame(message: String?, expected: Any?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Expected <$expected>, actual <$actual> is not same.\" }, actual === expected)\n    }\n\n    /**\n     * Asserts that the specified values are not the same instance.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertNotSame(message: String?, illegal: Any?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Expected not same as <$actual>.\" }, actual !== illegal)\n    }\n\n    /**\n     * Asserts that the specified value is `null`.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertNull(message: String?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Expected value to be null, but was: <$actual>.\" }, actual == null)\n    }\n\n    /**\n     * Asserts that the specified value is not `null`.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertNotNull(message: String?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Expected value to be not null.\" }, actual != null)\n    }\n\n}\n\n/**\n * Checks applicability and provides Asserter instance\n */\ninterface AsserterContributor {\n    /**\n     * Provides [Asserter] instance or `null` depends on the current context.\n     *\n     * @return asserter instance or null if it is not applicable now\n     */\n    fun contribute(): Asserter?\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    requireNonNegativeLimit(limit)\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    requireNonNegativeLimit(limit)\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\ninternal fun requireNonNegativeLimit(limit: Int) =\n    require(limit >= 0) { \"Limit must be non-negative, but was $limit\" }\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    requireNonNegativeLimit(limit)\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence to a list of strings around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of strings around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n * @sample samples.text.Strings.splitToSequence\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.splitToSequence(regex: Regex, limit: Int = 0): Sequence<String> = regex.splitToSequence(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean\n\ninternal fun CharSequence?.contentEqualsIgnoreCaseImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this.equals(other, ignoreCase = true)\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (!this[i].equals(other[i], ignoreCase = true)) {\n            return false\n        }\n    }\n\n    return true\n}\n\ninternal fun CharSequence?.contentEqualsImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this == other\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (this[i] != other[i]) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and throws an exception otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrict\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrict(): Boolean = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> throw IllegalArgumentException(\"The string doesn't represent a boolean value: $this\")\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and `null` otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrictOrNull\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrictOrNull(): Boolean? = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> null\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test\n\n/**\n * Default [Asserter] implementation to avoid dependency on JUnit or TestNG.\n */\nobject DefaultAsserter : Asserter {\n    override fun fail(message: String?): Nothing {\n        if (message == null)\n            throw AssertionError()\n        else\n            throw AssertionError(message)\n    }\n\n    @SinceKotlin(\"1.4\")\n    override fun fail(message: String?, cause: Throwable?): Nothing {\n        throw AssertionErrorWithCause(message, cause)\n    }\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test\n\nimport kotlin.reflect.KClass\n\n/**\n * Takes the given [block] of test code and _doesn't_ execute it.\n *\n * This keeps the code under test referenced, but doesn't actually test it until it is implemented.\n */\nactual fun todo(block: () -> Unit) {\n    // println(\"TODO at \" + (Exception() as java.lang.Throwable).getStackTrace()?.get(1) + \" for \" + block)\n    println(\"TODO at \" + block)\n}\n\n/** Platform-specific construction of AssertionError with cause */\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun AssertionErrorWithCause(message: String?, cause: Throwable?): AssertionError =\n    AssertionError(message, cause)\n\n\n@PublishedApi\ninternal actual fun <T : Throwable> checkResultIsFailure(exceptionClass: KClass<T>, message: String?, blockResult: Result<Unit>): T {\n    blockResult.fold(\n        onSuccess = {\n            asserter.fail(messagePrefix(message) + \"Expected an exception of $exceptionClass to be thrown, but was completed successfully.\")\n        },\n        onFailure = { e ->\n            if (exceptionClass.isInstance(e)) {\n                @Suppress(\"UNCHECKED_CAST\")\n                return e as T\n            }\n            asserter.fail(messagePrefix(message) + \"Expected an exception of $exceptionClass to be thrown, but was $e\", e)\n        }\n    )\n}\n\n\n/**\n * Provides the JS implementation of asserter\n */\ninternal actual fun lookupAsserter(): Asserter = DefaultJsAsserter","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test\n\nimport kotlin.math.abs\n\ninternal fun messagePrefix(message: String?) = if (message == null) \"\" else \"$message. \"\ninternal expect fun lookupAsserter(): Asserter\n\n@PublishedApi // required to get stable name as it's called from box tests\ninternal fun overrideAsserter(value: Asserter?): Asserter? = _asserter.also { _asserter = value }\n\n\nprivate fun checkAbsoluteTolerance(absoluteTolerance: Double) {\n    require(absoluteTolerance >= 0.0) { \"Illegal negative absolute tolerance <$absoluteTolerance>.\" }\n    require(!absoluteTolerance.isNaN()) { \"Illegal NaN absolute tolerance <$absoluteTolerance>.\" }\n}\n\ninternal fun checkDoublesAreEqual(\n    expected: Double,\n    actual: Double,\n    absoluteTolerance: Double,\n    message: String?,\n    shouldFail: Boolean = false\n) {\n    checkAbsoluteTolerance(absoluteTolerance)\n    val equal = expected.toBits() == actual.toBits() || abs(expected - actual) <= absoluteTolerance\n\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected <$expected> with absolute tolerance <$absoluteTolerance>, actual <$actual>.\" },\n        equal != shouldFail\n    )\n}\n\ninternal fun checkFloatsAreEqual(\n    expected: Float,\n    actual: Float,\n    absoluteTolerance: Float,\n    message: String?,\n    shouldFail: Boolean = false\n) {\n    checkAbsoluteTolerance(absoluteTolerance.toDouble())\n    val equal = expected.toBits() == actual.toBits() || abs(expected - actual) <= absoluteTolerance\n\n    asserter.assertTrue(\n        { messagePrefix(message) + \"Expected <$expected> with absolute tolerance <$absoluteTolerance>, actual <$actual>.\" },\n        equal != shouldFail\n    )\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nimport kotlin.test.*\n\n/**\n * Functions in this file are exposed in the root package to simplify their use from JavaScript.\n * For example: require('kotlin-test').setAdapter({ /* Your custom [FrameworkAdapter] here */ });\n */\n\n/**\n * Overrides current framework adapter with a provided instance of [FrameworkAdapter]. Use in order to support custom test frameworks.\n *\n * Also some string arguments are supported. Use \"qunit\" to set the adapter to [QUnit](https://qunitjs.com/), \"mocha\" for\n * [Mocha](https://mochajs.org/), \"jest\" for [Jest](https://facebook.github.io/jest/),\n * \"jasmine\" for [Jasmine](https://github.com/jasmine/jasmine), and \"auto\" to detect one of those frameworks automatically.\n *\n * If this function is not called, the test framework will be detected automatically (as if \"auto\" was passed).\n *\n */\n@JsName(\"setAdapter\")\ninternal fun setAdapter(adapter: dynamic) = kotlin.test.setAdapter(adapter)","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test\n\n/**\n * Marks a function as a test.\n */\n@Target(AnnotationTarget.FUNCTION)\npublic actual annotation class Test\n\n/**\n * Marks a test or a suite as ignored.\n */\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)\npublic actual annotation class Ignore\n\n/**\n * Marks a function to be invoked before each test.\n */\n@Target(AnnotationTarget.FUNCTION)\npublic actual annotation class BeforeTest\n\n/**\n * Marks a function to be invoked after each test.\n */\n@Target(AnnotationTarget.FUNCTION)\npublic actual annotation class AfterTest\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test\n\n/**\n * Describes the result of an assertion execution.\n */\npublic external interface AssertionResult {\n    val result: Boolean\n    val expected: Any?\n    val actual: Any?\n    val lazyMessage: () -> String?\n}\n\ninternal var assertHook: (AssertionResult) -> Unit = { _ -> }\n\ninternal object DefaultJsAsserter : Asserter {\n    private var e: Any? = undefined\n    private var a: Any? = undefined\n\n    override fun assertEquals(message: String?, expected: Any?, actual: Any?) {\n        e = expected\n        a = actual\n        super.assertEquals(message, expected, actual)\n    }\n\n    override fun assertNotEquals(message: String?, illegal: Any?, actual: Any?) {\n        e = illegal\n        a = actual\n        super.assertNotEquals(message, illegal, actual)\n    }\n\n    override fun assertSame(message: String?, expected: Any?, actual: Any?) {\n        e = expected\n        a = actual\n        super.assertSame(message, expected, actual)\n    }\n\n    override fun assertNotSame(message: String?, illegal: Any?, actual: Any?) {\n        e = illegal\n        a = actual\n        super.assertNotSame(message, illegal, actual)\n    }\n\n    override fun assertNull(message: String?, actual: Any?) {\n        a = actual\n        super.assertNull(message, actual)\n    }\n\n    override fun assertNotNull(message: String?, actual: Any?) {\n        a = actual\n        super.assertNotNull(message, actual)\n    }\n\n    override fun assertTrue(lazyMessage: () -> String?, actual: Boolean) {\n        if (!actual) {\n            failWithMessage(lazyMessage, null)\n        } else {\n            invokeHook(true, lazyMessage)\n        }\n    }\n\n    override fun assertTrue(message: String?, actual: Boolean) {\n        assertTrue({ message }, actual)\n    }\n\n    override fun fail(message: String?): Nothing {\n        fail(message, null)\n    }\n\n    @SinceKotlin(\"1.4\")\n    override fun fail(message: String?, cause: Throwable?): Nothing {\n        failWithMessage({ message }, cause)\n    }\n\n    private inline fun failWithMessage(lazyMessage: () -> String?, cause: Throwable?): Nothing {\n        val message = lazyMessage()\n        invokeHook(false) { message }\n        throw AssertionErrorWithCause(message, cause)\n    }\n\n    private fun invokeHook(result: Boolean, lazyMessage: () -> String?) {\n        try {\n            assertHook(object : AssertionResult {\n                override val result: Boolean = result\n                override val expected: Any? = e\n                override val actual: Any? = a\n                override val lazyMessage: () -> String? = lazyMessage\n            })\n        } finally {\n            e = undefined\n            a = undefined\n        }\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test\n\nimport kotlin.test.adapters.*\n\n/**\n * Overrides current framework adapter with a provided instance of [FrameworkAdapter]. Use in order to support custom test frameworks.\n *\n * Also some string arguments are supported. Use \"qunit\" to set the adapter to [QUnit](https://qunitjs.com/), \"mocha\" for\n * [Mocha](https://mochajs.org/), \"jest\" for [Jest](https://facebook.github.io/jest/),\n * \"jasmine\" for [Jasmine](https://github.com/jasmine/jasmine), and \"auto\" to detect one of those frameworks automatically.\n *\n * If this function is not called, the test framework will be detected automatically (as if \"auto\" was passed).\n *\n */\ninternal fun setAdapter(adapter: dynamic) {\n    if (js(\"typeof adapter === 'string'\")) {\n        NAME_TO_ADAPTER[adapter]?.let {\n            setAdapter(it.invoke())\n        } ?: throw IllegalArgumentException(\"Unsupported test framework adapter: '$adapter'\")\n    } else {\n        currentAdapter = adapter\n    }\n}\n\n/**\n * Use in order to define which action should be taken by the test framework on the [AssertionResult].\n */\ninternal fun setAssertHook(hook: (AssertionResult) -> Unit) {\n    assertHook = hook\n}\n\n\n/**\n * The functions below are used by the compiler to describe the tests structure, e.g.\n *\n * suite('a suite', false, function() {\n *   suite('a subsuite', false, function() {\n *     test('a test', false, function() {...});\n *     test('an ignored/pending test', true, function() {...});\n *   });\n *   suite('an ignored/pending test', true, function() {...});\n * });\n */\n\n@JsName(\"suite\")\ninternal fun suite(name: String, ignored: Boolean, suiteFn: () -> Unit) {\n    adapter().suite(name, ignored, suiteFn)\n}\n\n@JsName(\"test\")\ninternal fun test(name: String, ignored: Boolean, testFn: () -> Any?) {\n    adapter().test(name, ignored, testFn)\n}\n\ninternal var currentAdapter: FrameworkAdapter? = null\n\ninternal fun adapter(): FrameworkAdapter {\n    val result = currentAdapter ?: detectAdapter()\n    currentAdapter = result\n    return result\n}\n\n@JsName(\"kotlinTest\")\nexternal val kotlinTestNamespace: KotlinTestNamespace\n\nexternal interface KotlinTestNamespace {\n    val adapterTransformer: ((FrameworkAdapter) -> FrameworkAdapter)?\n}\n\ninternal fun detectAdapter(): FrameworkAdapter {\n    val frameworkAdapter = when {\n        isQUnit() -> QUnitAdapter()\n        isJasmine() -> JasmineLikeAdapter()\n        else -> BareAdapter()\n    }\n    return if (jsTypeOf(kotlinTestNamespace) != \"undefined\") {\n        val adapterTransform = kotlinTestNamespace\n            .adapterTransformer\n        if (adapterTransform !== null) {\n            adapterTransform(frameworkAdapter)\n        } else frameworkAdapter\n    } else frameworkAdapter\n}\n\ninternal val NAME_TO_ADAPTER: Map<String, () -> FrameworkAdapter> = mapOf(\n    \"qunit\" to ::QUnitAdapter,\n    \"jasmine\" to ::JasmineLikeAdapter,\n    \"mocha\" to ::JasmineLikeAdapter,\n    \"jest\" to ::JasmineLikeAdapter,\n    \"auto\" to ::detectAdapter\n)","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * Function corresponding to JavaScript's `typeof` operator\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"UNUSED_PARAMETER\")\npublic inline fun jsTypeOf(a: Any?): String = js(\"typeof a\")\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test.adapters\n\nimport kotlin.test.FrameworkAdapter\n\n/**\n * A fallback adapter for the case when no framework is detected.\n */\ninternal open class BareAdapter : FrameworkAdapter {\n\n    override fun suite(name: String, ignored: Boolean, suiteFn: () -> Unit) {\n        if (!ignored) {\n            suiteFn()\n        }\n    }\n\n    override fun test(name: String, ignored: Boolean, testFn: () -> Any?) {\n        if (!ignored) {\n            testFn()\n        }\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test.adapters\n\n/**\n * The [QUnit](http://qunitjs.com/) API\n */\ninternal external object QUnit {\n    fun module(name: String, suiteFn: () -> Unit): Unit\n    fun test(name: String, testFn: (dynamic) -> Any?): Unit\n    fun skip(name: String, testFn: (dynamic) -> Any?): Unit\n}\n\n/*\n * Jasmine/Mocha/Jest API\n */\n\ninternal external fun describe(name: String, fn: () -> Unit)\ninternal external fun xdescribe(name: String, fn: () -> Unit)\ninternal external fun it(name: String, fn: () -> Any?)\ninternal external fun xit(name: String, fn: () -> Any?)\n\ninternal fun isQUnit() = js(\"typeof QUnit !== 'undefined'\")\n\ninternal fun isJasmine() = js(\"typeof describe === 'function' && typeof it === 'function'\")","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test.adapters\n\nimport kotlin.test.FrameworkAdapter\n\n/**\n * [Jasmine](https://github.com/jasmine/jasmine) adapter.\n * Also used for [Mocha](https://mochajs.org/) and [Jest](https://facebook.github.io/jest/).\n */\ninternal class JasmineLikeAdapter : FrameworkAdapter {\n    override fun suite(name: String, ignored: Boolean, suiteFn: () -> Unit) {\n        if (ignored) {\n            xdescribe(name, suiteFn)\n        } else {\n            describe(name, suiteFn)\n        }\n    }\n\n    override fun test(name: String, ignored: Boolean, testFn: () -> Any?) {\n        if (ignored) {\n            xit(name, testFn)\n        } else {\n            it(name, testFn)\n        }\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test.adapters\n\nimport kotlin.test.FrameworkAdapter\nimport kotlin.test.assertHook\nimport kotlin.test.assertTrue\n\n/**\n * [QUnit](http://qunitjs.com/) adapter\n */\ninternal class QUnitAdapter : FrameworkAdapter {\n    var ignoredSuite = false;\n\n    override fun suite(name: String, ignored: Boolean, suiteFn: () -> Unit) {\n        val prevIgnore = ignoredSuite\n        ignoredSuite = ignoredSuite or ignored\n        QUnit.module(name, suiteFn)\n        ignoredSuite = prevIgnore\n    }\n\n    override fun test(name: String, ignored: Boolean, testFn: () -> Any?) {\n        if (ignored or ignoredSuite) {\n            QUnit.skip(name, wrapTest(testFn))\n        } else {\n            QUnit.test(name, wrapTest(testFn))\n        }\n    }\n\n    private fun wrapTest(testFn: () -> Any?): (dynamic) -> Any? = { assert ->\n        var assertionsHappened = false\n        assertHook = { testResult ->\n            assertionsHappened = true\n            assert.ok(testResult.result, testResult.lazyMessage())\n        }\n        val possiblePromise = testFn()\n        if (!assertionsHappened) {\n            assertTrue(true, \"A test with no assertions is considered successful\")\n        }\n        possiblePromise\n    }\n}"],"names":[],"mappings":"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B;MAAA,QAAoB,I;IAClD,cAAS,cAAK,OAAL,EAAc,KAAd,C;EACb,C;8EAEA,yB;IAAA,qD;IAAA,kC;MAKI,aAAa,QAAb,EAAuB,OAAvB,C;IACJ,C;GANA,C;gFAQA,yB;IAAA,qD;IAAA,2C;MAKI,aAAa,QAAb,EAAuB,OAAvB,EAAgC,OAAhC,C;IACJ,C;GANA,C;wFAQA,yB;IAAA,qE;IH/ZA,iC;IAAA,qB;IAxCQ,uD;IGucR,wB;MHxZW,Q;;QACI,OAlDH,WGkd+B,KHhapB,EAlDX,C;;QAmDN,gC;UACS,OA3CH,WAAO,cA2CI,CA3CJ,CAAP,C;;UAwCD,O;;MGiaP,4BAAqB,IAArB,EHjaA,IGiaA,C;K;GATJ,C;0FAWA,yB;IAAA,qE;IH1aA,iC;IAAA,qB;IAxCQ,uD;IGkdR,iC;MHnaW,Q;;QACI,OAlDH,WGgekC,KH9avB,EAlDX,C;;QAmDN,gC;UACS,OA3CH,WAAO,cA2CI,CA3CJ,CAAP,C;;UAwCD,O;;MG+aP,4BAAqB,OAArB,EH/aA,IG+aA,C;K;GAZJ,C;EAcA,oD;IH3V0B,gB;IADT,gBG8Vb,WH9V6B,kB;IACzB,sB;MAAkB,QG6VtB,WH7VsB,2C,IAAA,U;MAAV,SG+VJ,cAAS,cAAK,yBAAyB,qEAA9B,C;;MAGT,OHjWc,S;;EGoW1B,C;gGAEA,yB;IAAA,gC;IAqBA,qE;IHzdA,iC;IAAA,qB;IAxCQ,uD;IG4eR,2C;MAQmD,uB;QAAA,UAAmB,I;MAClE,mC;MHtcO,Q;;QACI,OAlDH,WGuf2B,KHrchB,EAlDX,C;;QAmDN,gC;UACS,OA3CH,WAAO,cA2CI,CA3CJ,CAAP,C;;UAwCD,O;;MGscP,OAuBA,qBAAqB,cAArB,EAvB0B,OAuB1B,EH7dA,IG6dA,C;K;GAhCJ,C;kGAWA,yB;IAUA,qE;IHzdA,iC;IAAA,qB;IAxCQ,uD;IGufR,wC;MHxcW,Q;;QACI,OAlDH,WGigBwH,KH/c7G,EAlDX,C;;QAmDN,gC;UACS,OA3CH,WAAO,cA2CI,CA3CJ,CAAP,C;;UAwCD,O;;MGgdmF,OAa1F,qBAb0G,cAa1G,EAb0H,IAa1H,EH7dA,IG6dA,C;K;GArBJ,C;kGAUA,yB;IA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"}